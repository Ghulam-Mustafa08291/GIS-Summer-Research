10th iteration code
this has parameter drop down and button for visualzing forecast difference,here i previously added check if the 16 days are being overlapped across two months 
so that hisotircal preicpitaiton value can be calculated accordingly,and in this code i did the same check and working for temperature too so its working all good rn

// Final version with Weighted Historical Average for BOTH Temp & Precip
var pakistanDistricts = ee.FeatureCollection('projects/ee-mustafaasghar66/assets/gadm36_PAK_3');
var dataFC = ee.FeatureCollection('projects/ee-mustafaasghar66/assets/Pakistan_Climate_2014_2024');

// Get current date and calculate forecast period
var today = ee.Date(Date.now());
var forecastEndDate = today.advance(16, 'day');

// GFS dataset for forecast data. We look for the most recent forecast run.
var gfsDataset = ee.ImageCollection('NOAA/GFS0P25')
  .filterDate(today.advance(-1, 'day'), today.advance(1, 'day'))
  .filter(ee.Filter.lte('forecast_hours', 384)) // 16 days = 384 hours
  .filter(ee.Filter.gte('forecast_hours', 0));

// Global variables for UI management
var loadingLabel = null;
var loadingPanel = null;
var districtLabel = null;
var districtInfoPanel = null;
var districtInfoTitle = null;
var panelDistrictWidgets = [];
var keepRotating = true;
var districtLoadingSymbol = null;
var debugLayerPrecip = null;
var debugLayerTemp = null;

// --- UI SETUP ---
var panel = ui.Panel({ style: {width: '400px', padding: '20px'} });
panel.add(ui.Label({value: 'Comparision between Forecast and Historical data in Pakistan', style: {fontSize: '20px', fontWeight: 'bold', margin: '0 0 20px 0'}}));
panel.add(ui.Label({
  value: 'This tool compares the 16-day weather forecast with long-term historical averages for each district in Pakistan.\n\n' +
         '1. Select a weather parameter.\n' +
         '2. Click "Calculate Anomalies".\n' +
         '3. The map will color districts based on the forecast anomaly:\n' +
         '   - Blue: Forecast is below historical average.\n' +
         '   - Green: Forecast is near historical average.\n' +
         '   - Red: Forecast is above historical average.\n' +
         '4. Click a district for detailed values.',
  style: { fontSize: '14px', margin: '0 0 20px 0', whiteSpace: 'pre-line', color: '#555' }
}));
panel.add(ui.Label('1. Select Weather Parameter:', {fontWeight: 'bold', fontSize: '16px'}));
var parameterSelect = ui.Select({
  items: [{label: 'Temperature (Â°C)', value: 'temperature'}, {label: 'Precipitation (mm)', value: 'precipitation'}],
  value: 'precipitation',
  style: { margin: '10px 0 20px 0', width: '360px' }
});
panel.add(parameterSelect);
var analyzeButton = ui.Button({
  label: 'Visualize Forecast',
  onClick: function() { var parameter = parameterSelect.getValue(); if (parameter) { updateVisualizationWithBatching(parameter); } },
  style: { margin: '10px 0 0 0', width: '360px', fontWeight: 'bold', border: '2px solid black', backgroundColor: '#f0f0f0', color: 'black' }
});
panel.add(analyzeButton);

panel.add(ui.Label('Debug Tools:', {fontWeight: 'bold', margin: '15px 0 5px 0'}));
var debugCheckboxPrecip = ui.Checkbox({ label: 'Show GFS Grid (Precipitation Rate)', value: false });
var debugCheckboxTemp = ui.Checkbox({ label: 'Show GFS Grid (Temperature)', value: false });
debugCheckboxPrecip.onChange(function(checked) {
  if (debugLayerPrecip) { Map.remove(debugLayerPrecip); }
  if (checked) {
    debugCheckboxTemp.setValue(false, false); if (debugLayerTemp) { Map.remove(debugLayerTemp); }
    var forecastImage = latestForecast.filter(ee.Filter.eq('forecast_hours', 6)).first();
    if (forecastImage) {
      var visParams = {min: 0, max: 0.005, palette: ['#ffffff', '#0000ff', '#00ffff', '#00ff00', '#ffff00', '#ff0000']};
      debugLayerPrecip = ui.Map.Layer(forecastImage.select('precipitation_rate'), visParams, 'GFS Grid (Precip Rate)');
      Map.layers().insert(1, debugLayerPrecip);
    } else { print("Could not find forecast image for hour 6."); }
  }
});
debugCheckboxTemp.onChange(function(checked) {
  if (debugLayerTemp) { Map.remove(debugLayerTemp); }
  if (checked) {
    debugCheckboxPrecip.setValue(false, false); if (debugLayerPrecip) { Map.remove(debugLayerPrecip); }
    var forecastImage = latestForecast.filter(ee.Filter.eq('forecast_hours', 6)).first();
    if (forecastImage) {
      var visParams = {min: 0, max: 45, palette: ['#000080', '#0000ff', '#00ffff', '#ffff00', '#ff0000', '#800000']};
      debugLayerTemp = ui.Map.Layer(forecastImage.select('temperature_2m_above_ground'), visParams, 'GFS Grid (Temp)');
      Map.layers().insert(1, debugLayerTemp);
    } else { print("Could not find forecast image for hour 6."); }
  }
});
panel.add(debugCheckboxPrecip);
panel.add(debugCheckboxTemp);

var dateInfo = ui.Label({ value: 'Forecast Period: Today + 16 days\nData Source: NOAA GFS 0.25Â°', style: { fontSize: '11px', margin: '15px 0 0 0', fontStyle: 'italic', color: '#666' }});
panel.add(dateInfo);
ui.root.insert(0, panel);
var legend = ui.Panel({ style: { position: 'bottom-left', padding: '8px 15px', border: '1px solid #ccc' } });
var legendTitle = ui.Label({ value: 'Forecast vs Historical', style: { fontWeight: 'bold', fontSize: '16px', margin: '0 0 4px 0', padding: '0' } });
legend.add(legendTitle);
var makeColorBarParams = function(palette) { return { bbox: [0, 0, 1, 0.1], dimensions: '250x10', format: 'png', min: 0, max: 1, palette: palette, }; };
var colorBar = ui.Thumbnail({ image: ee.Image.pixelLonLat().select(0), params: makeColorBarParams(['#0000FF', '#00FF00', '#FF0000']), style: {stretch: 'horizontal', margin: '0px 8px', maxHeight: '24px'}, });
legend.add(colorBar);
var legendLabels = ui.Panel({ widgets: [ ui.Label('Below Avg', {margin:'4px 8px'}), ui.Label('Near Avg', {margin: '4px 8px', textAlign: 'center', stretch: 'horizontal'}), ui.Label('Above Avg', {margin: '4px 8px', textAlign: 'right', stretch: 'horizontal'}) ], layout: ui.Panel.Layout.flow('horizontal') });
legend.add(legendLabels);
Map.add(legend);
var latestForecastRun = gfsDataset.sort('creation_time', false).first().get('creation_time');
var latestForecast = gfsDataset.filter(ee.Filter.eq('creation_time', latestForecastRun));

// --- UI HELPER FUNCTIONS ---
function showLoadingIndicator(message) {
  hideLoadingIndicator(); hideDistrictLoadingIndicator();
  loadingPanel = ui.Panel({ style: { backgroundColor: '#e8f4fd', border: '2px solid #3498db', margin: '10px 0', padding: '15px' } });
  var loadingTitle = ui.Label({ value: 'ðŸ”® Processing Forecast...', style: { fontSize: '16px', fontWeight: 'bold', color: '#2980b9', margin: '0 0 5px 0' } });
  loadingLabel = ui.Label({ value: message || 'Analyzing GFS data...', style: { fontSize: '14px', color: '#34495e', margin: '0 0 10px 0' } });
  var loadingSymbol = ui.Label({ value: 'âŸ³', style: { fontSize: '24px', color: '#3498db', textAlign: 'center', fontWeight: 'bold' } });
  loadingPanel.add(loadingTitle).add(loadingLabel).add(loadingSymbol);
  var insertIndex = panel.widgets().indexOf(analyzeButton) + 1;
  panel.insert(insertIndex, loadingPanel);
  var rotationSymbols = ['ðŸŒ', 'ðŸŒŽ', 'ðŸŒ']; var currentSymbolIndex = 0;
  var rotateSymbol = function() { if (loadingSymbol && loadingPanel) { currentSymbolIndex = (currentSymbolIndex + 1) % rotationSymbols.length; loadingSymbol.setValue(rotationSymbols[currentSymbolIndex]); ui.util.setTimeout(rotateSymbol, 400); } };
  ui.util.setTimeout(rotateSymbol, 400);
}
function updateLoadingIndicator(message) { if (loadingLabel) { loadingLabel.setValue(message); } }
function hideLoadingIndicator() { if (loadingPanel) { panel.remove(loadingPanel); loadingPanel = null; loadingLabel = null; } }
function showDistrictLoadingIndicator() {
  clearPanel(); keepRotating = true;
  districtInfoPanel = ui.Panel({ style: { backgroundColor: '#e8f4fd', border: '2px solid #3498db', margin: '10px 0', padding: '15px' } });
  districtInfoTitle = ui.Label({ value: 'â³ Loading District Info...', style: { fontSize: '16px', fontWeight: 'bold', color: '#2980b9', margin: '0 0 5px 0' } });
  districtLoadingSymbol = ui.Label({ value: 'âŸ³', style: { fontSize: '24px', color: '#3498db', textAlign: 'center', fontWeight: 'bold' } });
  districtInfoPanel.add(districtInfoTitle).add(districtLoadingSymbol);
  panel.add(districtInfoPanel); panelDistrictWidgets.push(districtInfoPanel);
  var rotationSymbols = ['ðŸŒ', 'ðŸŒŽ', 'ðŸŒ']; var currentSymbolIndex = 0;
  var rotateSymbol = function() { if (districtLoadingSymbol && districtInfoPanel && keepRotating === true) { currentSymbolIndex = (currentSymbolIndex + 1) % rotationSymbols.length; districtLoadingSymbol.setValue(rotationSymbols[currentSymbolIndex]); ui.util.setTimeout(rotateSymbol, 300); } };
  ui.util.setTimeout(rotateSymbol, 300);
}
function updateDistrictInfoPanel(title, message) {
    keepRotating = false; districtInfoTitle.setValue(title); districtLoadingSymbol.setValue('âœ…');
    var infoLabel = ui.Label(message, { whiteSpace: 'pre-line', fontSize: '14px', color: '#34495e' });
    districtInfoPanel.add(infoLabel);
}
function hideDistrictLoadingIndicator() { if (districtInfoPanel) { panel.remove(districtInfoPanel); districtInfoPanel = null; } }
function clearPanel(){ panelDistrictWidgets.forEach(function(widget) { panel.remove(widget); }); panelDistrictWidgets = []; }

// --- CORE LOGIC (Complex method with Weighted Historical for BOTH) ---
function calculateForecastAnomaliesForDistrict_Complex(district, parameter, gfsData, historicalData) {
  var districtName = ee.Feature(district).get('NAME_3');
  var districtGeometry = ee.Feature(district).geometry();
  var districtHistoricalData = historicalData.filter(ee.Filter.eq('district_name', districtName)).first();
  return ee.Algorithms.If( ee.Algorithms.IsEqual(districtHistoricalData, null), ee.Feature(district).set({ 'difference': -999, 'debug': 'no_historical' }),
    (function() {
      var forecastValue; var historicalValue16DayEqv;
      if (parameter === 'precipitation') {
        var gfsBand = 'precipitation_rate';
        var hourlySteps = ee.List.sequence(1, 120);
        var hourlyValues = hourlySteps.map(function(hour) {
          var hourImage = latestForecast.filter(ee.Filter.eq('forecast_hours', hour)).first();
          return ee.Algorithms.If(hourImage, (function() {
              var rate = ee.Image(hourImage).select(gfsBand).reduceRegion({reducer: ee.Reducer.mean(), geometry: districtGeometry, scale: 27830, bestEffort: true}).get(gfsBand);
              var sanitizedRate = ee.Number(ee.Algorithms.If(rate, rate, 0));
              return sanitizedRate.multiply(3600);
            })(), 0);
        });
        var totalHourlyPrecip = ee.Number(hourlyValues.reduce(ee.Reducer.sum()));
        var threeHourlySteps = ee.List.sequence(123, 384, 3);
        var threeHourlyValues = threeHourlySteps.map(function(hour) {
            var hourImage = latestForecast.filter(ee.Filter.eq('forecast_hours', hour)).first();
            return ee.Algorithms.If(hourImage, (function() {
                var rate = ee.Image(hourImage).select(gfsBand).reduceRegion({reducer: ee.Reducer.mean(), geometry: districtGeometry, scale: 27830, bestEffort: true}).get(gfsBand);
                var sanitizedRate = ee.Number(ee.Algorithms.If(rate, rate, 0));
                return sanitizedRate.multiply(10800);
            })(), 0);
        });
        var totalThreeHourlyPrecip = ee.Number(threeHourlyValues.reduce(ee.Reducer.sum()));
        forecastValue = totalHourlyPrecip.add(totalThreeHourlyPrecip);
      } else { // Temperature
        var gfsBand = 'temperature_2m_above_ground';
        var allForecasts = latestForecast.select(gfsBand);
        var meanCelsiusImage = allForecasts.mean();
        forecastValue = meanCelsiusImage.reduceRegion({reducer: ee.Reducer.mean(), geometry: districtGeometry, scale: 27830, bestEffort: true}).get(gfsBand);
        forecastValue = ee.Number(ee.Algorithms.If(forecastValue, forecastValue, 0));
      }
      
      var startDay = today.get('day');
      var startMonth = today.get('month');
      var endMonth = forecastEndDate.get('month');
      
      startDay.evaluate(function(startDay){
        print("start day is="+startDay)
      })
      
      startMonth.evaluate(function(startMonth){
        print("start month is="+ startMonth)
      })
      
      endMonth.evaluate(function(endMonth){
        print("end month is="+ endMonth)
      })
      
      if (parameter === 'precipitation') {
        var monthColumns = ee.List(['rainfall_jan', 'rainfall_feb', 'rainfall_mar', 'rainfall_apr', 'rainfall_may', 'rainfall_jun','rainfall_jul', 'rainfall_aug', 'rainfall_sep', 'rainfall_oct', 'rainfall_nov', 'rainfall_dec']);
        historicalValue16DayEqv = ee.Number(ee.Algorithms.If(
          startMonth.neq(endMonth),
          (function() { // Logic for crossover
            var daysInMonthList = ee.List([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]);
            var daysInStartMonth = ee.Number(daysInMonthList.get(startMonth.subtract(1)));
            var daysInFirstPeriod = daysInStartMonth.subtract(startDay).add(1);
            var historicalValue1 = ee.Number(districtHistoricalData.get(monthColumns.get(startMonth.subtract(1))));
            var portion1 = historicalValue1.divide(daysInStartMonth).multiply(daysInFirstPeriod);
            var daysInSecondPeriod = ee.Number(16).subtract(daysInFirstPeriod);
            var daysInEndMonth = ee.Number(daysInMonthList.get(endMonth.subtract(1)));
            var historicalValue2 = ee.Number(districtHistoricalData.get(monthColumns.get(endMonth.subtract(1))));
            var portion2 = historicalValue2.divide(daysInEndMonth).multiply(daysInSecondPeriod);
            return portion1.add(portion2);
          })(),
          (function() { // Logic for single month
            var historicalValue = ee.Number(districtHistoricalData.get(monthColumns.get(startMonth.subtract(1))));
            var is31DayMonth = startMonth.eq(1).or(startMonth.eq(3)).or(startMonth.eq(5)).or(startMonth.eq(7)).or(startMonth.eq(8)).or(startMonth.eq(10)).or(startMonth.eq(12));
            var daysInMonth = ee.Number(ee.Algorithms.If(is31DayMonth, 31, ee.Algorithms.If(startMonth.eq(2), 28, 30)));
            return historicalValue.divide(daysInMonth).multiply(16);
          })()
        ));
      } else { // Temperature - Apply NEW weighted logic
         var monthColumns = ee.List(['temperature_jan', 'temperature_feb', 'temperature_mar', 'temperature_apr', 'temperature_may', 'temperature_jun','temperature_jul', 'temperature_aug', 'temperature_sep', 'temperature_oct', 'temperature_nov', 'temperature_dec']);
         historicalValue16DayEqv = ee.Number(ee.Algorithms.If(
           startMonth.neq(endMonth),
           // --- TRUE: The period crosses two months (Weighted Average) ---
           (function() {
             var daysInMonthList = ee.List([31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]); // Simplified daysInMonth
             var daysInStartMonth = ee.Number(daysInMonthList.get(startMonth.subtract(1)));
             var daysInFirstPeriod = daysInStartMonth.subtract(startDay).add(1);
             var historicalTemp1 = ee.Number(districtHistoricalData.get(monthColumns.get(startMonth.subtract(1))));
             
             var daysInSecondPeriod = ee.Number(16).subtract(daysInFirstPeriod);
             var historicalTemp2 = ee.Number(districtHistoricalData.get(monthColumns.get(endMonth.subtract(1))));
             
             // Weighted average: ((Value1 * Days1) + (Value2 * Days2)) / TotalDays
             var weightedSum = (historicalTemp1.multiply(daysInFirstPeriod)).add(historicalTemp2.multiply(daysInSecondPeriod));
             return weightedSum.divide(16);
           })(),
           // --- FALSE: The period is in a single month (Simple Average) ---
           (function() {
             return ee.Number(districtHistoricalData.get(monthColumns.get(startMonth.subtract(1))));
           })()
         ));
      }

      var difference = ee.Number(forecastValue).subtract(historicalValue16DayEqv);
      return ee.Feature(district).set({'forecast_value': forecastValue, 'historical_value_16day': historicalValue16DayEqv, 'difference': difference, 'district_name': districtName, 'parameter': parameter, 'debug': 'ok'});
    })()
  );
}

// --- BATCH PROCESSING VISUALIZATION WORKFLOW ---
function updateVisualizationWithBatching(parameter) {
  Map.unlisten(); Map.layers().reset([Map.layers().get(0)]);
  showLoadingIndicator("Please wait while we load the data... Do Not click on Visualize forecast again.");
  pakistanDistricts.toList(pakistanDistricts.size()).evaluate(function(districtsList) {
    var BATCH_SIZE = 5; var processedFeatures = []; var totalDistricts = districtsList.length;
    var numBatches = Math.ceil(totalDistricts / BATCH_SIZE);
    function processBatch(startIndex) {
      if (startIndex >= totalDistricts) { finalizeVisualization(processedFeatures, parameter); return; }
      var currentBatchNumber = Math.floor(startIndex / BATCH_SIZE) + 1;
      updateLoadingIndicator("Please wait while we load the data... Do Not click on Visualize forecast again.");
      var endIndex = Math.min(startIndex + BATCH_SIZE, totalDistricts);
      var currentBatchList = districtsList.slice(startIndex, endIndex);
      var batchCollection = ee.FeatureCollection(currentBatchList);
      var districtsWithDiffs = batchCollection.map(function(district) { return calculateForecastAnomaliesForDistrict_Complex(district, parameter, gfsDataset, dataFC); });
      districtsWithDiffs.evaluate(function(processedBatch, error) {
        if (error) { print('Error processing batch starting at index ' + startIndex + ':', error); } else if (processedBatch && processedBatch.features) { processedFeatures = processedFeatures.concat(processedBatch.features); }
        ui.util.setTimeout(function() { processBatch(endIndex); }, 200);
      });
    }
    processBatch(0);
  });
}

function finalizeVisualization(processedFeatures, parameter) {
  updateLoadingIndicator("Finalizing visualization...");
  var validFeatures = processedFeatures.filter(function(f) { return f.properties.difference !== -999 && f.properties.difference !== null; });
  if (validFeatures.length === 0) { print("ERROR: No districts were successfully processed."); hideLoadingIndicator(); return; }
  var finalCollection = ee.FeatureCollection(validFeatures);
  var differences = finalCollection.aggregate_array('difference');
  differences.evaluate(function(diffs, error) {
    if (error) { print('Error aggregating differences:', error); hideLoadingIndicator(); return; }
    if (!diffs || diffs.length === 0) { print("No valid differences found."); hideLoadingIndicator(); return; }
    var maxAbsDiff = diffs.reduce(function(max, val) { return Math.max(max, Math.abs(val)); }, 0);
    print("Max absolute difference for vis range:", maxAbsDiff);
    createVisualizationLayer(finalCollection, -maxAbsDiff, maxAbsDiff, parameter);
    addClickHandler(finalCollection, parameter);
    hideLoadingIndicator();
  });
}

function createVisualizationLayer(districtsWithDiffs, minDiff, maxDiff, parameter) {
  var paintedImage = ee.Image(0).mask(0).paint({ featureCollection: districtsWithDiffs, color: 'difference' });
  var visParams = { min: minDiff, max: maxDiff, palette: ['#0000FF', '#00FF00', '#FF0000'] };
  var unit = (parameter === 'precipitation') ? 'mm' : 'Â°C';
  legendTitle.setValue('Difference (' + unit + ')');
  var layerTitle = '16-Day ' + parameter.charAt(0).toUpperCase() + parameter.slice(1) + ' Forecast Difference';
  Map.addLayer(paintedImage, visParams, layerTitle);
  Map.addLayer(pakistanDistricts.style({color: '000000', width: 1, fillColor: '00000000'}), {}, 'District Boundaries');
}

function addClickHandler(districtsWithDiffs, parameter) {
  Map.onClick(function(coords) {
    var point = ee.Geometry.Point([coords.lon, coords.lat]);
    var clickedDistrict = districtsWithDiffs.filterBounds(point).first();
    showDistrictLoadingIndicator();
    clickedDistrict.evaluate(function(district) {
      if (district && district.properties) {
        var props = district.properties;
        var forecastValue = props.forecast_value !== null ? props.forecast_value.toFixed(2) : '0.00';
        var historicalValue = props.historical_value_16day ? props.historical_value_16day.toFixed(2) : 'N/A';
        var difference = props.difference ? props.difference.toFixed(2) : 'N/A';
        var forecastUnitLabel = parameter === 'precipitation' ? 'mm' : 'Â°C';
        // Updated label for temperature
        var historicalUnitLabel = parameter === 'precipitation' ? 'mm' : 'Â°C';
        var unit = (parameter === 'precipitation') ? 'mm' : 'Â°C';
        var differenceDirection = '';
        if (props.difference) {
            var diffNum = Number(props.difference);
            if (diffNum > 0) { differenceDirection = ' (above historical)'; }
            else if (diffNum < 0) { differenceDirection = ' (below historical)'; }
            else { differenceDirection = ' (matches historical)'; }
        }
        var info = 'District: ' + (props.district_name || 'Unknown') + '\n' +
                   'Parameter: ' + parameter.charAt(0).toUpperCase() + parameter.slice(1) + '\n' +
                   '-------------------------------------\n' +
                   'Next 16-Day Forecast: ' + forecastValue +  ' '+ forecastUnitLabel  + '\n' +
                   'Next 16-Day historical average: ' + historicalValue + ' ' + historicalUnitLabel + '\n' +
                   'Difference: ' + difference + ' ' + unit + differenceDirection;
        updateDistrictInfoPanel("District Forecast Details", info);
      } else {
        updateDistrictInfoPanel("No Data", "No forecast data available for this location");
      }
    });
  });
}

// --- INITIAL MAP SETUP ---
Map.setCenter(69.3451, 30.3753, 6);
Map.addLayer(pakistanDistricts.style({color: 'gray', width: 1, fillColor: '00000000'}), {}, 'Pakistan Districts');

print("GFS Forecast Anomaly Analysis Ready!");
